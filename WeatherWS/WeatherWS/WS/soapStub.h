/* soapStub.h
   Generated by gSOAP 2.8.82 for weather.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_WS1	"http://WebXml.com.cn/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20882
# error "GSOAP VERSION 20882 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class WS1__ArrayOfString;	/* weather.h:154 */
class _WS1__getSupportCity;	/* weather.h:156 */
class _WS1__getSupportCityResponse;	/* weather.h:158 */
class _WS1__getSupportProvince;	/* weather.h:160 */
class _WS1__getSupportProvinceResponse;	/* weather.h:162 */
class _WS1__getSupportDataSet;	/* weather.h:164 */
class _WS1__getSupportDataSetResponse_getSupportDataSetResult;	/* weather.h:360 */
class _WS1__getSupportDataSetResponse;	/* weather.h:166 */
class _WS1__getWeatherbyCityName;	/* weather.h:168 */
class _WS1__getWeatherbyCityNameResponse;	/* weather.h:170 */
class _WS1__getWeatherbyCityNamePro;	/* weather.h:172 */
class _WS1__getWeatherbyCityNameProResponse;	/* weather.h:174 */
class _WS1__DataSet;	/* weather.h:176 */
class _WS1__getCountryCityByIp;	/* weather.h:178 */
class _WS1__getCountryCityByIpResponse;	/* weather.h:180 */
class _WS1__getGeoIPContext;	/* weather.h:182 */
class _WS1__getGeoIPContextResponse;	/* weather.h:184 */
class _WS1__getVersionTime;	/* weather.h:186 */
class _WS1__getVersionTimeResponse;	/* weather.h:188 */
struct __WS1__getSupportCity;	/* weather.h:818 */
struct __WS1__getSupportProvince;	/* weather.h:892 */
struct __WS1__getSupportDataSet;	/* weather.h:968 */
struct __WS1__getWeatherbyCityName;	/* weather.h:1052 */
struct __WS1__getWeatherbyCityNamePro;	/* weather.h:1125 */
struct __WS1__getSupportCity_;	/* weather.h:1199 */
struct __WS1__getSupportProvince_;	/* weather.h:1273 */
struct __WS1__getSupportDataSet_;	/* weather.h:1349 */
struct __WS1__getWeatherbyCityName_;	/* weather.h:1433 */
struct __WS1__getWeatherbyCityNamePro_;	/* weather.h:1506 */
struct __WS1__getCountryCityByIp;	/* weather.h:1580 */
struct __WS1__getGeoIPContext;	/* weather.h:1654 */
struct __WS1__getVersionTime;	/* weather.h:1727 */
struct __WS1__getCountryCityByIp_;	/* weather.h:1801 */
struct __WS1__getGeoIPContext_;	/* weather.h:1875 */
struct __WS1__getVersionTime_;	/* weather.h:1948 */

/* weather.h:154 */
#ifndef SOAP_TYPE_WS1__ArrayOfString
#define SOAP_TYPE_WS1__ArrayOfString (9)
/* complex XML schema type 'WS1:ArrayOfString': */
class SOAP_CMAC WS1__ArrayOfString {
      public:
        /// Optional element 'WS1:string' of XML schema type 'xsd:string'
        std::vector<std::wstring> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_WS1__ArrayOfString
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__ArrayOfString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__ArrayOfString, default initialized and not managed by a soap context
        virtual WS1__ArrayOfString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__ArrayOfString); }
      public:
        /// Constructor with default initializations
        WS1__ArrayOfString() : string(), soap() { }
        virtual ~WS1__ArrayOfString() { }
        /// Friend allocator used by soap_new_WS1__ArrayOfString(struct soap*, int)
        friend SOAP_FMAC1 WS1__ArrayOfString * SOAP_FMAC2 soap_instantiate_WS1__ArrayOfString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:156 */
#ifndef SOAP_TYPE__WS1__getSupportCity
#define SOAP_TYPE__WS1__getSupportCity (10)
/* complex XML schema type 'WS1:getSupportCity': */
class SOAP_CMAC _WS1__getSupportCity {
      public:
        /// Optional element 'WS1:byProvinceName' of XML schema type 'xsd:string'
        wchar_t *byProvinceName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportCity
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportCity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportCity, default initialized and not managed by a soap context
        virtual _WS1__getSupportCity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportCity); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportCity() : byProvinceName(), soap() { }
        virtual ~_WS1__getSupportCity() { }
        /// Friend allocator used by soap_new__WS1__getSupportCity(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportCity * SOAP_FMAC2 soap_instantiate__WS1__getSupportCity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:158 */
#ifndef SOAP_TYPE__WS1__getSupportCityResponse
#define SOAP_TYPE__WS1__getSupportCityResponse (11)
/* complex XML schema type 'WS1:getSupportCityResponse': */
class SOAP_CMAC _WS1__getSupportCityResponse {
      public:
        /// Optional element 'WS1:getSupportCityResult' of XML schema type 'WS1:ArrayOfString'
        WS1__ArrayOfString *getSupportCityResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportCityResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportCityResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportCityResponse, default initialized and not managed by a soap context
        virtual _WS1__getSupportCityResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportCityResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportCityResponse() : getSupportCityResult(), soap() { }
        virtual ~_WS1__getSupportCityResponse() { }
        /// Friend allocator used by soap_new__WS1__getSupportCityResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportCityResponse * SOAP_FMAC2 soap_instantiate__WS1__getSupportCityResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:160 */
#ifndef SOAP_TYPE__WS1__getSupportProvince
#define SOAP_TYPE__WS1__getSupportProvince (12)
/* complex XML schema type 'WS1:getSupportProvince': */
class SOAP_CMAC _WS1__getSupportProvince {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportProvince
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportProvince; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportProvince, default initialized and not managed by a soap context
        virtual _WS1__getSupportProvince *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportProvince); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportProvince() : soap() { }
        virtual ~_WS1__getSupportProvince() { }
        /// Friend allocator used by soap_new__WS1__getSupportProvince(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportProvince * SOAP_FMAC2 soap_instantiate__WS1__getSupportProvince(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:162 */
#ifndef SOAP_TYPE__WS1__getSupportProvinceResponse
#define SOAP_TYPE__WS1__getSupportProvinceResponse (13)
/* complex XML schema type 'WS1:getSupportProvinceResponse': */
class SOAP_CMAC _WS1__getSupportProvinceResponse {
      public:
        /// Optional element 'WS1:getSupportProvinceResult' of XML schema type 'WS1:ArrayOfString'
        WS1__ArrayOfString *getSupportProvinceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportProvinceResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportProvinceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportProvinceResponse, default initialized and not managed by a soap context
        virtual _WS1__getSupportProvinceResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportProvinceResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportProvinceResponse() : getSupportProvinceResult(), soap() { }
        virtual ~_WS1__getSupportProvinceResponse() { }
        /// Friend allocator used by soap_new__WS1__getSupportProvinceResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportProvinceResponse * SOAP_FMAC2 soap_instantiate__WS1__getSupportProvinceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:164 */
#ifndef SOAP_TYPE__WS1__getSupportDataSet
#define SOAP_TYPE__WS1__getSupportDataSet (14)
/* complex XML schema type 'WS1:getSupportDataSet': */
class SOAP_CMAC _WS1__getSupportDataSet {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportDataSet
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportDataSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportDataSet, default initialized and not managed by a soap context
        virtual _WS1__getSupportDataSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportDataSet); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportDataSet() : soap() { }
        virtual ~_WS1__getSupportDataSet() { }
        /// Friend allocator used by soap_new__WS1__getSupportDataSet(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportDataSet * SOAP_FMAC2 soap_instantiate__WS1__getSupportDataSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:360 */
#ifndef SOAP_TYPE__WS1__getSupportDataSetResponse_getSupportDataSetResult
#define SOAP_TYPE__WS1__getSupportDataSetResponse_getSupportDataSetResult (33)
/* complex XML schema type 'WS1:getSupportDataSetResponse-getSupportDataSetResult': */
class SOAP_CMAC _WS1__getSupportDataSetResponse_getSupportDataSetResult {
      public:
        /// Required element 'xsd:schema' of XML schema type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportDataSetResponse_getSupportDataSetResult
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportDataSetResponse_getSupportDataSetResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportDataSetResponse_getSupportDataSetResult, default initialized and not managed by a soap context
        virtual _WS1__getSupportDataSetResponse_getSupportDataSetResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportDataSetResponse_getSupportDataSetResult); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportDataSetResponse_getSupportDataSetResult() : xsd__schema(), __any() { }
        virtual ~_WS1__getSupportDataSetResponse_getSupportDataSetResult() { }
        /// Friend allocator used by soap_new__WS1__getSupportDataSetResponse_getSupportDataSetResult(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportDataSetResponse_getSupportDataSetResult * SOAP_FMAC2 soap_instantiate__WS1__getSupportDataSetResponse_getSupportDataSetResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:166 */
#ifndef SOAP_TYPE__WS1__getSupportDataSetResponse
#define SOAP_TYPE__WS1__getSupportDataSetResponse (15)
/* complex XML schema type 'WS1:getSupportDataSetResponse': */
class SOAP_CMAC _WS1__getSupportDataSetResponse {
      public:
        /// Optional element 'WS1:getSupportDataSetResult' of XML schema type 'WS1:getSupportDataSetResponse-getSupportDataSetResult'
        _WS1__getSupportDataSetResponse_getSupportDataSetResult *getSupportDataSetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getSupportDataSetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getSupportDataSetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getSupportDataSetResponse, default initialized and not managed by a soap context
        virtual _WS1__getSupportDataSetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getSupportDataSetResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getSupportDataSetResponse() : getSupportDataSetResult(), soap() { }
        virtual ~_WS1__getSupportDataSetResponse() { }
        /// Friend allocator used by soap_new__WS1__getSupportDataSetResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getSupportDataSetResponse * SOAP_FMAC2 soap_instantiate__WS1__getSupportDataSetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:168 */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityName
#define SOAP_TYPE__WS1__getWeatherbyCityName (16)
/* complex XML schema type 'WS1:getWeatherbyCityName': */
class SOAP_CMAC _WS1__getWeatherbyCityName {
      public:
        /// Optional element 'WS1:theCityName' of XML schema type 'xsd:string'
        wchar_t *theCityName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getWeatherbyCityName
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getWeatherbyCityName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getWeatherbyCityName, default initialized and not managed by a soap context
        virtual _WS1__getWeatherbyCityName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getWeatherbyCityName); }
      public:
        /// Constructor with default initializations
        _WS1__getWeatherbyCityName() : theCityName(), soap() { }
        virtual ~_WS1__getWeatherbyCityName() { }
        /// Friend allocator used by soap_new__WS1__getWeatherbyCityName(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getWeatherbyCityName * SOAP_FMAC2 soap_instantiate__WS1__getWeatherbyCityName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:170 */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityNameResponse
#define SOAP_TYPE__WS1__getWeatherbyCityNameResponse (17)
/* complex XML schema type 'WS1:getWeatherbyCityNameResponse': */
class SOAP_CMAC _WS1__getWeatherbyCityNameResponse {
      public:
        /// Optional element 'WS1:getWeatherbyCityNameResult' of XML schema type 'WS1:ArrayOfString'
        WS1__ArrayOfString *getWeatherbyCityNameResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getWeatherbyCityNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getWeatherbyCityNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getWeatherbyCityNameResponse, default initialized and not managed by a soap context
        virtual _WS1__getWeatherbyCityNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getWeatherbyCityNameResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getWeatherbyCityNameResponse() : getWeatherbyCityNameResult(), soap() { }
        virtual ~_WS1__getWeatherbyCityNameResponse() { }
        /// Friend allocator used by soap_new__WS1__getWeatherbyCityNameResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getWeatherbyCityNameResponse * SOAP_FMAC2 soap_instantiate__WS1__getWeatherbyCityNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:172 */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityNamePro
#define SOAP_TYPE__WS1__getWeatherbyCityNamePro (18)
/* complex XML schema type 'WS1:getWeatherbyCityNamePro': */
class SOAP_CMAC _WS1__getWeatherbyCityNamePro {
      public:
        /// Optional element 'WS1:theCityName' of XML schema type 'xsd:string'
        wchar_t *theCityName;
        /// Optional element 'WS1:theUserID' of XML schema type 'xsd:string'
        wchar_t *theUserID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getWeatherbyCityNamePro
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getWeatherbyCityNamePro; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getWeatherbyCityNamePro, default initialized and not managed by a soap context
        virtual _WS1__getWeatherbyCityNamePro *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getWeatherbyCityNamePro); }
      public:
        /// Constructor with default initializations
        _WS1__getWeatherbyCityNamePro() : theCityName(), theUserID(), soap() { }
        virtual ~_WS1__getWeatherbyCityNamePro() { }
        /// Friend allocator used by soap_new__WS1__getWeatherbyCityNamePro(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getWeatherbyCityNamePro * SOAP_FMAC2 soap_instantiate__WS1__getWeatherbyCityNamePro(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:174 */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityNameProResponse
#define SOAP_TYPE__WS1__getWeatherbyCityNameProResponse (19)
/* complex XML schema type 'WS1:getWeatherbyCityNameProResponse': */
class SOAP_CMAC _WS1__getWeatherbyCityNameProResponse {
      public:
        /// Optional element 'WS1:getWeatherbyCityNameProResult' of XML schema type 'WS1:ArrayOfString'
        WS1__ArrayOfString *getWeatherbyCityNameProResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getWeatherbyCityNameProResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getWeatherbyCityNameProResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getWeatherbyCityNameProResponse, default initialized and not managed by a soap context
        virtual _WS1__getWeatherbyCityNameProResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getWeatherbyCityNameProResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getWeatherbyCityNameProResponse() : getWeatherbyCityNameProResult(), soap() { }
        virtual ~_WS1__getWeatherbyCityNameProResponse() { }
        /// Friend allocator used by soap_new__WS1__getWeatherbyCityNameProResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getWeatherbyCityNameProResponse * SOAP_FMAC2 soap_instantiate__WS1__getWeatherbyCityNameProResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:176 */
#ifndef SOAP_TYPE__WS1__DataSet
#define SOAP_TYPE__WS1__DataSet (20)
/* complex XML schema type 'WS1:DataSet': */
class SOAP_CMAC _WS1__DataSet {
      public:
        /// Required element 'xsd:schema' of XML schema type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__DataSet
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__DataSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__DataSet, default initialized and not managed by a soap context
        virtual _WS1__DataSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__DataSet); }
      public:
        /// Constructor with default initializations
        _WS1__DataSet() : xsd__schema(), __any(), soap() { }
        virtual ~_WS1__DataSet() { }
        /// Friend allocator used by soap_new__WS1__DataSet(struct soap*, int)
        friend SOAP_FMAC1 _WS1__DataSet * SOAP_FMAC2 soap_instantiate__WS1__DataSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:178 */
#ifndef SOAP_TYPE__WS1__getCountryCityByIp
#define SOAP_TYPE__WS1__getCountryCityByIp (21)
/* complex XML schema type 'WS1:getCountryCityByIp': */
class SOAP_CMAC _WS1__getCountryCityByIp {
      public:
        /// Optional element 'WS1:theIpAddress' of XML schema type 'xsd:string'
        wchar_t *theIpAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getCountryCityByIp
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getCountryCityByIp; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getCountryCityByIp, default initialized and not managed by a soap context
        virtual _WS1__getCountryCityByIp *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getCountryCityByIp); }
      public:
        /// Constructor with default initializations
        _WS1__getCountryCityByIp() : theIpAddress(), soap() { }
        virtual ~_WS1__getCountryCityByIp() { }
        /// Friend allocator used by soap_new__WS1__getCountryCityByIp(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getCountryCityByIp * SOAP_FMAC2 soap_instantiate__WS1__getCountryCityByIp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:180 */
#ifndef SOAP_TYPE__WS1__getCountryCityByIpResponse
#define SOAP_TYPE__WS1__getCountryCityByIpResponse (22)
/* complex XML schema type 'WS1:getCountryCityByIpResponse': */
class SOAP_CMAC _WS1__getCountryCityByIpResponse {
      public:
        /// Optional element 'WS1:getCountryCityByIpResult' of XML schema type 'WS1:ArrayOfString'
        WS1__ArrayOfString *getCountryCityByIpResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getCountryCityByIpResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getCountryCityByIpResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getCountryCityByIpResponse, default initialized and not managed by a soap context
        virtual _WS1__getCountryCityByIpResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getCountryCityByIpResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getCountryCityByIpResponse() : getCountryCityByIpResult(), soap() { }
        virtual ~_WS1__getCountryCityByIpResponse() { }
        /// Friend allocator used by soap_new__WS1__getCountryCityByIpResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getCountryCityByIpResponse * SOAP_FMAC2 soap_instantiate__WS1__getCountryCityByIpResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:182 */
#ifndef SOAP_TYPE__WS1__getGeoIPContext
#define SOAP_TYPE__WS1__getGeoIPContext (23)
/* complex XML schema type 'WS1:getGeoIPContext': */
class SOAP_CMAC _WS1__getGeoIPContext {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getGeoIPContext
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getGeoIPContext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getGeoIPContext, default initialized and not managed by a soap context
        virtual _WS1__getGeoIPContext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getGeoIPContext); }
      public:
        /// Constructor with default initializations
        _WS1__getGeoIPContext() : soap() { }
        virtual ~_WS1__getGeoIPContext() { }
        /// Friend allocator used by soap_new__WS1__getGeoIPContext(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getGeoIPContext * SOAP_FMAC2 soap_instantiate__WS1__getGeoIPContext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:184 */
#ifndef SOAP_TYPE__WS1__getGeoIPContextResponse
#define SOAP_TYPE__WS1__getGeoIPContextResponse (24)
/* complex XML schema type 'WS1:getGeoIPContextResponse': */
class SOAP_CMAC _WS1__getGeoIPContextResponse {
      public:
        /// Optional element 'WS1:getGeoIPContextResult' of XML schema type 'WS1:ArrayOfString'
        WS1__ArrayOfString *getGeoIPContextResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getGeoIPContextResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getGeoIPContextResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getGeoIPContextResponse, default initialized and not managed by a soap context
        virtual _WS1__getGeoIPContextResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getGeoIPContextResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getGeoIPContextResponse() : getGeoIPContextResult(), soap() { }
        virtual ~_WS1__getGeoIPContextResponse() { }
        /// Friend allocator used by soap_new__WS1__getGeoIPContextResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getGeoIPContextResponse * SOAP_FMAC2 soap_instantiate__WS1__getGeoIPContextResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:186 */
#ifndef SOAP_TYPE__WS1__getVersionTime
#define SOAP_TYPE__WS1__getVersionTime (25)
/* complex XML schema type 'WS1:getVersionTime': */
class SOAP_CMAC _WS1__getVersionTime {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getVersionTime
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getVersionTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getVersionTime, default initialized and not managed by a soap context
        virtual _WS1__getVersionTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getVersionTime); }
      public:
        /// Constructor with default initializations
        _WS1__getVersionTime() : soap() { }
        virtual ~_WS1__getVersionTime() { }
        /// Friend allocator used by soap_new__WS1__getVersionTime(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getVersionTime * SOAP_FMAC2 soap_instantiate__WS1__getVersionTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:188 */
#ifndef SOAP_TYPE__WS1__getVersionTimeResponse
#define SOAP_TYPE__WS1__getVersionTimeResponse (26)
/* complex XML schema type 'WS1:getVersionTimeResponse': */
class SOAP_CMAC _WS1__getVersionTimeResponse {
      public:
        /// Optional element 'WS1:getVersionTimeResult' of XML schema type 'xsd:string'
        wchar_t *getVersionTimeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getVersionTimeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getVersionTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getVersionTimeResponse, default initialized and not managed by a soap context
        virtual _WS1__getVersionTimeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getVersionTimeResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getVersionTimeResponse() : getVersionTimeResult(), soap() { }
        virtual ~_WS1__getVersionTimeResponse() { }
        /// Friend allocator used by soap_new__WS1__getVersionTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getVersionTimeResponse * SOAP_FMAC2 soap_instantiate__WS1__getVersionTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:818 */
#ifndef SOAP_TYPE___WS1__getSupportCity
#define SOAP_TYPE___WS1__getSupportCity (38)
/* Wrapper: */
struct SOAP_CMAC __WS1__getSupportCity {
      public:
        /** Optional element 'WS1:getSupportCity' of XML schema type 'WS1:getSupportCity' */
        _WS1__getSupportCity *WS1__getSupportCity;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getSupportCity */
        long soap_type() const { return SOAP_TYPE___WS1__getSupportCity; }
        /** Constructor with member initializations */
        __WS1__getSupportCity() : WS1__getSupportCity() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getSupportCity * SOAP_FMAC2 soap_instantiate___WS1__getSupportCity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:892 */
#ifndef SOAP_TYPE___WS1__getSupportProvince
#define SOAP_TYPE___WS1__getSupportProvince (42)
/* Wrapper: */
struct SOAP_CMAC __WS1__getSupportProvince {
      public:
        /** Optional element 'WS1:getSupportProvince' of XML schema type 'WS1:getSupportProvince' */
        _WS1__getSupportProvince *WS1__getSupportProvince;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getSupportProvince */
        long soap_type() const { return SOAP_TYPE___WS1__getSupportProvince; }
        /** Constructor with member initializations */
        __WS1__getSupportProvince() : WS1__getSupportProvince() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getSupportProvince * SOAP_FMAC2 soap_instantiate___WS1__getSupportProvince(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:968 */
#ifndef SOAP_TYPE___WS1__getSupportDataSet
#define SOAP_TYPE___WS1__getSupportDataSet (46)
/* Wrapper: */
struct SOAP_CMAC __WS1__getSupportDataSet {
      public:
        /** Optional element 'WS1:getSupportDataSet' of XML schema type 'WS1:getSupportDataSet' */
        _WS1__getSupportDataSet *WS1__getSupportDataSet;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getSupportDataSet */
        long soap_type() const { return SOAP_TYPE___WS1__getSupportDataSet; }
        /** Constructor with member initializations */
        __WS1__getSupportDataSet() : WS1__getSupportDataSet() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getSupportDataSet * SOAP_FMAC2 soap_instantiate___WS1__getSupportDataSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1052 */
#ifndef SOAP_TYPE___WS1__getWeatherbyCityName
#define SOAP_TYPE___WS1__getWeatherbyCityName (50)
/* Wrapper: */
struct SOAP_CMAC __WS1__getWeatherbyCityName {
      public:
        /** Optional element 'WS1:getWeatherbyCityName' of XML schema type 'WS1:getWeatherbyCityName' */
        _WS1__getWeatherbyCityName *WS1__getWeatherbyCityName;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getWeatherbyCityName */
        long soap_type() const { return SOAP_TYPE___WS1__getWeatherbyCityName; }
        /** Constructor with member initializations */
        __WS1__getWeatherbyCityName() : WS1__getWeatherbyCityName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getWeatherbyCityName * SOAP_FMAC2 soap_instantiate___WS1__getWeatherbyCityName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1125 */
#ifndef SOAP_TYPE___WS1__getWeatherbyCityNamePro
#define SOAP_TYPE___WS1__getWeatherbyCityNamePro (54)
/* Wrapper: */
struct SOAP_CMAC __WS1__getWeatherbyCityNamePro {
      public:
        /** Optional element 'WS1:getWeatherbyCityNamePro' of XML schema type 'WS1:getWeatherbyCityNamePro' */
        _WS1__getWeatherbyCityNamePro *WS1__getWeatherbyCityNamePro;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getWeatherbyCityNamePro */
        long soap_type() const { return SOAP_TYPE___WS1__getWeatherbyCityNamePro; }
        /** Constructor with member initializations */
        __WS1__getWeatherbyCityNamePro() : WS1__getWeatherbyCityNamePro() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getWeatherbyCityNamePro * SOAP_FMAC2 soap_instantiate___WS1__getWeatherbyCityNamePro(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1199 */
#ifndef SOAP_TYPE___WS1__getSupportCity_
#define SOAP_TYPE___WS1__getSupportCity_ (56)
/* Wrapper: */
struct SOAP_CMAC __WS1__getSupportCity_ {
      public:
        /** Optional element 'WS1:getSupportCity' of XML schema type 'WS1:getSupportCity' */
        _WS1__getSupportCity *WS1__getSupportCity;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getSupportCity_ */
        long soap_type() const { return SOAP_TYPE___WS1__getSupportCity_; }
        /** Constructor with member initializations */
        __WS1__getSupportCity_() : WS1__getSupportCity() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getSupportCity_ * SOAP_FMAC2 soap_instantiate___WS1__getSupportCity_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1273 */
#ifndef SOAP_TYPE___WS1__getSupportProvince_
#define SOAP_TYPE___WS1__getSupportProvince_ (58)
/* Wrapper: */
struct SOAP_CMAC __WS1__getSupportProvince_ {
      public:
        /** Optional element 'WS1:getSupportProvince' of XML schema type 'WS1:getSupportProvince' */
        _WS1__getSupportProvince *WS1__getSupportProvince;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getSupportProvince_ */
        long soap_type() const { return SOAP_TYPE___WS1__getSupportProvince_; }
        /** Constructor with member initializations */
        __WS1__getSupportProvince_() : WS1__getSupportProvince() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getSupportProvince_ * SOAP_FMAC2 soap_instantiate___WS1__getSupportProvince_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1349 */
#ifndef SOAP_TYPE___WS1__getSupportDataSet_
#define SOAP_TYPE___WS1__getSupportDataSet_ (60)
/* Wrapper: */
struct SOAP_CMAC __WS1__getSupportDataSet_ {
      public:
        /** Optional element 'WS1:getSupportDataSet' of XML schema type 'WS1:getSupportDataSet' */
        _WS1__getSupportDataSet *WS1__getSupportDataSet;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getSupportDataSet_ */
        long soap_type() const { return SOAP_TYPE___WS1__getSupportDataSet_; }
        /** Constructor with member initializations */
        __WS1__getSupportDataSet_() : WS1__getSupportDataSet() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getSupportDataSet_ * SOAP_FMAC2 soap_instantiate___WS1__getSupportDataSet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1433 */
#ifndef SOAP_TYPE___WS1__getWeatherbyCityName_
#define SOAP_TYPE___WS1__getWeatherbyCityName_ (62)
/* Wrapper: */
struct SOAP_CMAC __WS1__getWeatherbyCityName_ {
      public:
        /** Optional element 'WS1:getWeatherbyCityName' of XML schema type 'WS1:getWeatherbyCityName' */
        _WS1__getWeatherbyCityName *WS1__getWeatherbyCityName;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getWeatherbyCityName_ */
        long soap_type() const { return SOAP_TYPE___WS1__getWeatherbyCityName_; }
        /** Constructor with member initializations */
        __WS1__getWeatherbyCityName_() : WS1__getWeatherbyCityName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getWeatherbyCityName_ * SOAP_FMAC2 soap_instantiate___WS1__getWeatherbyCityName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1506 */
#ifndef SOAP_TYPE___WS1__getWeatherbyCityNamePro_
#define SOAP_TYPE___WS1__getWeatherbyCityNamePro_ (64)
/* Wrapper: */
struct SOAP_CMAC __WS1__getWeatherbyCityNamePro_ {
      public:
        /** Optional element 'WS1:getWeatherbyCityNamePro' of XML schema type 'WS1:getWeatherbyCityNamePro' */
        _WS1__getWeatherbyCityNamePro *WS1__getWeatherbyCityNamePro;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getWeatherbyCityNamePro_ */
        long soap_type() const { return SOAP_TYPE___WS1__getWeatherbyCityNamePro_; }
        /** Constructor with member initializations */
        __WS1__getWeatherbyCityNamePro_() : WS1__getWeatherbyCityNamePro() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getWeatherbyCityNamePro_ * SOAP_FMAC2 soap_instantiate___WS1__getWeatherbyCityNamePro_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1580 */
#ifndef SOAP_TYPE___WS1__getCountryCityByIp
#define SOAP_TYPE___WS1__getCountryCityByIp (68)
/* Wrapper: */
struct SOAP_CMAC __WS1__getCountryCityByIp {
      public:
        /** Optional element 'WS1:getCountryCityByIp' of XML schema type 'WS1:getCountryCityByIp' */
        _WS1__getCountryCityByIp *WS1__getCountryCityByIp;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getCountryCityByIp */
        long soap_type() const { return SOAP_TYPE___WS1__getCountryCityByIp; }
        /** Constructor with member initializations */
        __WS1__getCountryCityByIp() : WS1__getCountryCityByIp() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getCountryCityByIp * SOAP_FMAC2 soap_instantiate___WS1__getCountryCityByIp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1654 */
#ifndef SOAP_TYPE___WS1__getGeoIPContext
#define SOAP_TYPE___WS1__getGeoIPContext (72)
/* Wrapper: */
struct SOAP_CMAC __WS1__getGeoIPContext {
      public:
        /** Optional element 'WS1:getGeoIPContext' of XML schema type 'WS1:getGeoIPContext' */
        _WS1__getGeoIPContext *WS1__getGeoIPContext;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getGeoIPContext */
        long soap_type() const { return SOAP_TYPE___WS1__getGeoIPContext; }
        /** Constructor with member initializations */
        __WS1__getGeoIPContext() : WS1__getGeoIPContext() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getGeoIPContext * SOAP_FMAC2 soap_instantiate___WS1__getGeoIPContext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1727 */
#ifndef SOAP_TYPE___WS1__getVersionTime
#define SOAP_TYPE___WS1__getVersionTime (76)
/* Wrapper: */
struct SOAP_CMAC __WS1__getVersionTime {
      public:
        /** Optional element 'WS1:getVersionTime' of XML schema type 'WS1:getVersionTime' */
        _WS1__getVersionTime *WS1__getVersionTime;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getVersionTime */
        long soap_type() const { return SOAP_TYPE___WS1__getVersionTime; }
        /** Constructor with member initializations */
        __WS1__getVersionTime() : WS1__getVersionTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getVersionTime * SOAP_FMAC2 soap_instantiate___WS1__getVersionTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1801 */
#ifndef SOAP_TYPE___WS1__getCountryCityByIp_
#define SOAP_TYPE___WS1__getCountryCityByIp_ (78)
/* Wrapper: */
struct SOAP_CMAC __WS1__getCountryCityByIp_ {
      public:
        /** Optional element 'WS1:getCountryCityByIp' of XML schema type 'WS1:getCountryCityByIp' */
        _WS1__getCountryCityByIp *WS1__getCountryCityByIp;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getCountryCityByIp_ */
        long soap_type() const { return SOAP_TYPE___WS1__getCountryCityByIp_; }
        /** Constructor with member initializations */
        __WS1__getCountryCityByIp_() : WS1__getCountryCityByIp() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getCountryCityByIp_ * SOAP_FMAC2 soap_instantiate___WS1__getCountryCityByIp_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1875 */
#ifndef SOAP_TYPE___WS1__getGeoIPContext_
#define SOAP_TYPE___WS1__getGeoIPContext_ (80)
/* Wrapper: */
struct SOAP_CMAC __WS1__getGeoIPContext_ {
      public:
        /** Optional element 'WS1:getGeoIPContext' of XML schema type 'WS1:getGeoIPContext' */
        _WS1__getGeoIPContext *WS1__getGeoIPContext;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getGeoIPContext_ */
        long soap_type() const { return SOAP_TYPE___WS1__getGeoIPContext_; }
        /** Constructor with member initializations */
        __WS1__getGeoIPContext_() : WS1__getGeoIPContext() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getGeoIPContext_ * SOAP_FMAC2 soap_instantiate___WS1__getGeoIPContext_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1948 */
#ifndef SOAP_TYPE___WS1__getVersionTime_
#define SOAP_TYPE___WS1__getVersionTime_ (82)
/* Wrapper: */
struct SOAP_CMAC __WS1__getVersionTime_ {
      public:
        /** Optional element 'WS1:getVersionTime' of XML schema type 'WS1:getVersionTime' */
        _WS1__getVersionTime *WS1__getVersionTime;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getVersionTime_ */
        long soap_type() const { return SOAP_TYPE___WS1__getVersionTime_; }
        /** Constructor with member initializations */
        __WS1__getVersionTime_() : WS1__getVersionTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getVersionTime_ * SOAP_FMAC2 soap_instantiate___WS1__getVersionTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:2268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (83)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:2268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (84)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:2268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (86)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:2268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (89)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:2268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (90)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* weather.h:144 */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (8)
typedef _XML _xsd__schema;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* _WS1__getSupportDataSetResponse_getSupportDataSetResult has binding name '_WS1__getSupportDataSetResponse_getSupportDataSetResult' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportDataSetResponse_getSupportDataSetResult
#define SOAP_TYPE__WS1__getSupportDataSetResponse_getSupportDataSetResult (33)
#endif

/* std::wstring has binding name 'std__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__wstring
#define SOAP_TYPE_std__wstring (27)
#endif

/* _WS1__getVersionTimeResponse has binding name '_WS1__getVersionTimeResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getVersionTimeResponse
#define SOAP_TYPE__WS1__getVersionTimeResponse (26)
#endif

/* _WS1__getVersionTime has binding name '_WS1__getVersionTime' for type '' */
#ifndef SOAP_TYPE__WS1__getVersionTime
#define SOAP_TYPE__WS1__getVersionTime (25)
#endif

/* _WS1__getGeoIPContextResponse has binding name '_WS1__getGeoIPContextResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getGeoIPContextResponse
#define SOAP_TYPE__WS1__getGeoIPContextResponse (24)
#endif

/* _WS1__getGeoIPContext has binding name '_WS1__getGeoIPContext' for type '' */
#ifndef SOAP_TYPE__WS1__getGeoIPContext
#define SOAP_TYPE__WS1__getGeoIPContext (23)
#endif

/* _WS1__getCountryCityByIpResponse has binding name '_WS1__getCountryCityByIpResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getCountryCityByIpResponse
#define SOAP_TYPE__WS1__getCountryCityByIpResponse (22)
#endif

/* _WS1__getCountryCityByIp has binding name '_WS1__getCountryCityByIp' for type '' */
#ifndef SOAP_TYPE__WS1__getCountryCityByIp
#define SOAP_TYPE__WS1__getCountryCityByIp (21)
#endif

/* _WS1__DataSet has binding name '_WS1__DataSet' for type '' */
#ifndef SOAP_TYPE__WS1__DataSet
#define SOAP_TYPE__WS1__DataSet (20)
#endif

/* _WS1__getWeatherbyCityNameProResponse has binding name '_WS1__getWeatherbyCityNameProResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityNameProResponse
#define SOAP_TYPE__WS1__getWeatherbyCityNameProResponse (19)
#endif

/* _WS1__getWeatherbyCityNamePro has binding name '_WS1__getWeatherbyCityNamePro' for type '' */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityNamePro
#define SOAP_TYPE__WS1__getWeatherbyCityNamePro (18)
#endif

/* _WS1__getWeatherbyCityNameResponse has binding name '_WS1__getWeatherbyCityNameResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityNameResponse
#define SOAP_TYPE__WS1__getWeatherbyCityNameResponse (17)
#endif

/* _WS1__getWeatherbyCityName has binding name '_WS1__getWeatherbyCityName' for type '' */
#ifndef SOAP_TYPE__WS1__getWeatherbyCityName
#define SOAP_TYPE__WS1__getWeatherbyCityName (16)
#endif

/* _WS1__getSupportDataSetResponse has binding name '_WS1__getSupportDataSetResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportDataSetResponse
#define SOAP_TYPE__WS1__getSupportDataSetResponse (15)
#endif

/* _WS1__getSupportDataSet has binding name '_WS1__getSupportDataSet' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportDataSet
#define SOAP_TYPE__WS1__getSupportDataSet (14)
#endif

/* _WS1__getSupportProvinceResponse has binding name '_WS1__getSupportProvinceResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportProvinceResponse
#define SOAP_TYPE__WS1__getSupportProvinceResponse (13)
#endif

/* _WS1__getSupportProvince has binding name '_WS1__getSupportProvince' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportProvince
#define SOAP_TYPE__WS1__getSupportProvince (12)
#endif

/* _WS1__getSupportCityResponse has binding name '_WS1__getSupportCityResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportCityResponse
#define SOAP_TYPE__WS1__getSupportCityResponse (11)
#endif

/* _WS1__getSupportCity has binding name '_WS1__getSupportCity' for type '' */
#ifndef SOAP_TYPE__WS1__getSupportCity
#define SOAP_TYPE__WS1__getSupportCity (10)
#endif

/* WS1__ArrayOfString has binding name 'WS1__ArrayOfString' for type 'WS1:ArrayOfString' */
#ifndef SOAP_TYPE_WS1__ArrayOfString
#define SOAP_TYPE_WS1__ArrayOfString (9)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (90)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (89)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (86)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (84)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (83)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (92)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (91)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (85)
#endif

/* _WS1__getVersionTime * has binding name 'PointerTo_WS1__getVersionTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getVersionTime
#define SOAP_TYPE_PointerTo_WS1__getVersionTime (73)
#endif

/* _WS1__getGeoIPContext * has binding name 'PointerTo_WS1__getGeoIPContext' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getGeoIPContext
#define SOAP_TYPE_PointerTo_WS1__getGeoIPContext (69)
#endif

/* _WS1__getCountryCityByIp * has binding name 'PointerTo_WS1__getCountryCityByIp' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getCountryCityByIp
#define SOAP_TYPE_PointerTo_WS1__getCountryCityByIp (65)
#endif

/* _WS1__getWeatherbyCityNamePro * has binding name 'PointerTo_WS1__getWeatherbyCityNamePro' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getWeatherbyCityNamePro
#define SOAP_TYPE_PointerTo_WS1__getWeatherbyCityNamePro (51)
#endif

/* _WS1__getWeatherbyCityName * has binding name 'PointerTo_WS1__getWeatherbyCityName' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getWeatherbyCityName
#define SOAP_TYPE_PointerTo_WS1__getWeatherbyCityName (47)
#endif

/* _WS1__getSupportDataSet * has binding name 'PointerTo_WS1__getSupportDataSet' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getSupportDataSet
#define SOAP_TYPE_PointerTo_WS1__getSupportDataSet (43)
#endif

/* _WS1__getSupportProvince * has binding name 'PointerTo_WS1__getSupportProvince' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getSupportProvince
#define SOAP_TYPE_PointerTo_WS1__getSupportProvince (39)
#endif

/* _WS1__getSupportCity * has binding name 'PointerTo_WS1__getSupportCity' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getSupportCity
#define SOAP_TYPE_PointerTo_WS1__getSupportCity (35)
#endif

/* _WS1__getSupportDataSetResponse_getSupportDataSetResult * has binding name 'PointerTo_WS1__getSupportDataSetResponse_getSupportDataSetResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getSupportDataSetResponse_getSupportDataSetResult
#define SOAP_TYPE_PointerTo_WS1__getSupportDataSetResponse_getSupportDataSetResult (34)
#endif

/* WS1__ArrayOfString * has binding name 'PointerToWS1__ArrayOfString' for type 'WS1:ArrayOfString' */
#ifndef SOAP_TYPE_PointerToWS1__ArrayOfString
#define SOAP_TYPE_PointerToWS1__ArrayOfString (32)
#endif

/* wchar_t * has binding name 'wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_wstring
#define SOAP_TYPE_wstring (31)
#endif

/* _xsd__schema has binding name '_xsd__schema' for type '' */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (8)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<std::wstring>  has binding name 'std__vectorTemplateOfstd__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__wstring
#define SOAP_TYPE_std__vectorTemplateOfstd__wstring (28)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
